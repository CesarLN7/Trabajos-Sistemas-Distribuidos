/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "claves-rpc.h"
#include "mensaje.h"
#include "claves/claves.c"

pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

bool_t
rpc_destroy_1_svc(int *result, struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;
	*result = destroy();
	return retval;
}

bool_t
rpc_set_value_1_svc(args_struct aux, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;
	// Variables del set_value
	int key = aux.key;
	char value1[MAXSTR];
	int N_value2 = aux.N_value2;
	double V_value2[MAXVEC];
	struct Coord value3;
	strcpy(value1, aux.value1);
	for (int i = 0; i < N_value2; i++) {
		V_value2[i] = aux.V_value2[i];
	}
	value3.x = aux.value3.x;
	value3.y = aux.value3.y;

	pthread_mutex_lock(&m);
	*result = set_value(key, value1, N_value2, V_value2, value3);
	pthread_mutex_unlock(&m);
	
	return retval;
}

bool_t
rpc_get_value_1_svc(int key, args_struct *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;
	// Variables del get_value
	char value1[MAXSTR];
	int N_value2;
	double V_value2[MAXVEC];
	struct Coord value3;
	
	pthread_mutex_lock(&m);
	result->key = get_value(key, value1, &N_value2, V_value2, &value3);
	pthread_mutex_unlock(&m);

	// Copiar los valores a result
	strcpy(result->value1, value1);
	result->N_value2 = N_value2;
	for (int i = 0; i < N_value2; i++) {
		result->V_value2[i] = V_value2[i];
	}
	result->value3.x = value3.x;
	result->value3.y = value3.y;

	return retval;
}

bool_t
rpc_modify_value_1_svc(args_struct aux, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;
	// Variables del modify_value
	int key = aux.key;
	char value1[MAXSTR];
	int N_value2 = aux.N_value2;
	double V_value2[MAXVEC];
	struct Coord value3;

	strcpy(value1, aux.value1);
	for (int i = 0; i < N_value2; i++) {
		V_value2[i] = aux.V_value2[i];
	}
	value3.x = aux.value3.x;
	value3.y = aux.value3.y;
	
	pthread_mutex_lock(&m);
	*result = modify_value(key, value1, N_value2, V_value2, value3);
	pthread_mutex_unlock(&m);
	
	return retval;
}

bool_t
rpc_delete_key_1_svc(int key, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;
	
	pthread_mutex_lock(&m);
	*result = delete_key(key);
	pthread_mutex_unlock(&m);
	
	return retval;
}

bool_t
rpc_exist_1_svc(int key, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;
	
	pthread_mutex_lock(&m);
	*result = exist(key);
	pthread_mutex_unlock(&m);
	
	return retval;
}

int
interfaz_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);
	return 1;
}
